---
description:
globs:
alwaysApply: true
---
# CLI å·¥å…·å¼€å‘è§„èŒƒ

## é¡¹ç›®æ¶æ„

### CLI å…¥å£å’Œå‘½ä»¤ç»“æ„
ä¸»å…¥å£æ–‡ä»¶ï¼š[src/cli.ts](mdc:src/cli.ts) - æ³¨å†Œæ‰€æœ‰ CLI å‘½ä»¤

```typescript
// CLI ä¸»å…¥å£ç»“æ„
import { Command } from 'commander';
import { initCommand } from '@/commands/init';
import { listCommand } from '@/commands/list';
import { addCommand } from '@/commands/add';

const program = new Command();

program
  .name('@qile-c/cursor-rules-cli')
  .description('ç”Ÿæˆå’Œç®¡ç† Cursor IDE AI åä½œè§„èŒƒçš„ CLI å·¥å…·')
  .version(process.env.npm_package_version || '1.0.0');

// æ³¨å†Œå‘½ä»¤
program
  .command('init')
  .description('ä¸ºå½“å‰é¡¹ç›®åˆå§‹åŒ– Cursor Rules')
  .option('-t, --template <template>', 'æŒ‡å®šæ¨¡æ¿ç±»å‹')
  .option('-f, --force', 'å¼ºåˆ¶è¦†ç›–å·²å­˜åœ¨çš„è§„åˆ™æ–‡ä»¶')
  .action(initCommand);
```

### å‘½ä»¤æ¨¡å—ç»“æ„
æ¯ä¸ªå‘½ä»¤åœ¨ [src/commands/](mdc:src/commands) ç›®å½•ä¸‹æœ‰ç‹¬ç«‹æ–‡ä»¶ï¼š
- [src/commands/init.ts](mdc:src/commands/init.ts) - åˆå§‹åŒ–é¡¹ç›®è§„åˆ™
- [src/commands/list.ts](mdc:src/commands/list.ts) - åˆ—å‡ºå¯ç”¨æ¨¡æ¿
- [src/commands/add.ts](mdc:src/commands/add.ts) - æ·»åŠ ç‰¹å®šè§„åˆ™
- [src/commands/config.ts](mdc:src/commands/config.ts) - é…ç½®ç®¡ç†

## å‘½ä»¤è®¾è®¡åŸåˆ™

### å‘½ä»¤å®ç°æ¨¡å¼
```typescript
// æ ‡å‡†å‘½ä»¤ç»“æ„
export async function commandName(
  args: string[],
  options: CommandOptions
): Promise<void> {
  try {
    // 1. éªŒè¯è¾“å…¥å‚æ•°
    validateInput(args, options);

    // 2. æ˜¾ç¤ºè¿›åº¦æŒ‡ç¤º
    const spinner = ora('æ‰§è¡Œæ“ä½œä¸­...').start();

    // 3. æ‰§è¡Œæ ¸å¿ƒé€»è¾‘
    const result = await executeCommand(args, options);

    // 4. æ›´æ–°è¿›åº¦çŠ¶æ€
    spinner.succeed('æ“ä½œå®Œæˆ');

    // 5. è¾“å‡ºç»“æœ
    displayResult(result);
  } catch (error) {
    spinner?.fail('æ“ä½œå¤±è´¥');
    handleError(error);
  }
}
```

### å‘½ä»¤é€‰é¡¹è®¾è®¡
- æ¯ä¸ªå‘½ä»¤éƒ½åº”è¯¥æœ‰æ¸…æ™°çš„èŒè´£å’Œç›®çš„
- æ”¯æŒ `--help` æ˜¾ç¤ºè¯¦ç»†å¸®åŠ©ä¿¡æ¯
- æä¾›ç®€çŸ­å’Œå®Œæ•´çš„é€‰é¡¹å½¢å¼: `-f, --force`
- ä¸ºæ‰€æœ‰äº¤äº’æä¾›éäº¤äº’æ¨¡å¼é€‰é¡¹

```typescript
// å‘½ä»¤é€‰é¡¹ç±»å‹å®šä¹‰
interface InitOptions {
  template?: TemplateType;
  force?: boolean;
  interactive?: boolean;
  dryRun?: boolean;
}

// é€‰é¡¹éªŒè¯
function validateInitOptions(options: InitOptions): void {
  if (options.template && !isValidTemplateType(options.template)) {
    const suggestions = getSimilarTemplates(options.template);
    throw new UserError(
      `æ— æ•ˆçš„æ¨¡æ¿ç±»å‹: ${options.template}`,
      suggestions.length > 0 ? [`å»ºè®®ä½¿ç”¨: ${suggestions.join(', ')}`] : []
    );
  }
}
```

## ç”¨æˆ·äº¤äº’è®¾è®¡

### äº¤äº’å¼å‘½ä»¤
ä½¿ç”¨ [inquirer.js](mdc:https:/www.npmjs.com/package/inquirer) æä¾›å‹å¥½çš„äº¤äº’ä½“éªŒï¼š

```typescript
import inquirer from 'inquirer';

// äº¤äº’å¼æ¨¡æ¿é€‰æ‹©
const answers = await inquirer.prompt([
  {
    type: 'list',
    name: 'template',
    message: 'è¯·é€‰æ‹©è¦ä½¿ç”¨çš„æ¨¡æ¿:',
    choices: availableTemplates.map(t => ({
      name: `${t.name} - ${t.description}`,
      value: t.id,
    })),
    default: recommendedTemplate?.id,
  },
  {
    type: 'confirm',
    name: 'force',
    message: 'æ˜¯å¦è¦†ç›–å·²å­˜åœ¨çš„è§„åˆ™æ–‡ä»¶?',
    default: false,
    when: (answers) => hasExistingRules(answers.template),
  },
  {
    type: 'checkbox',
    name: 'features',
    message: 'é€‰æ‹©è¦å¯ç”¨çš„åŠŸèƒ½:',
    choices: [
      { name: 'TypeScript æ”¯æŒ', value: 'typescript' },
      { name: 'æµ‹è¯•è§„åˆ™', value: 'testing' },
      { name: 'Git å·¥ä½œæµ', value: 'git-workflow' },
    ],
  },
]);
```

### è¾“å‡ºæ ¼å¼åŒ–
ä½¿ç”¨ [chalk](mdc:https:/www.npmjs.com/package/chalk) å’Œ [ora](mdc:https:/www.npmjs.com/package/ora) å¢å¼ºç”¨æˆ·ä½“éªŒï¼š

```typescript
import chalk from 'chalk';
import ora from 'ora';

// ç»Ÿä¸€çš„è¾“å‡ºæ ¼å¼
console.log(chalk.green('âœ… è§„åˆ™åˆå§‹åŒ–æˆåŠŸ'));
console.log(chalk.yellow('âš ï¸  å‘ç°å·²å­˜åœ¨çš„é…ç½®æ–‡ä»¶'));
console.log(chalk.red('âŒ æ¨¡æ¿ä¸å­˜åœ¨'));
console.log(chalk.blue('â„¹ï¸  æç¤ºä¿¡æ¯'));

// è¿›åº¦æŒ‡ç¤ºå™¨
const spinner = ora({
  text: 'æ­£åœ¨æ£€æµ‹é¡¹ç›®ç±»å‹...',
  spinner: 'dots',
}).start();

const projectInfo = await detectProject();
spinner.succeed(chalk.green('é¡¹ç›®ç±»å‹æ£€æµ‹å®Œæˆ'));

// è¡¨æ ¼è¾“å‡º
console.table(templates.map(t => ({
  ID: t.id,
  åç§°: t.name,
  åˆ†ç±»: t.category,
  æè¿°: t.description,
})));
```

## é”™è¯¯å¤„ç†ä¸ç”¨æˆ·åé¦ˆ

### é”™è¯¯åˆ†ç±»å¤„ç†
åœ¨ [src/utils/errors.ts](mdc:src/utils/errors.ts) ä¸­å®šä¹‰ï¼š

```typescript
// ç”¨æˆ·è¾“å…¥é”™è¯¯
export class UserError extends Error {
  constructor(
    message: string,
    public suggestions: string[] = [],
    public code?: string
  ) {
    super(message);
    this.name = 'UserError';
  }
}

// ç³»ç»Ÿè¿è¡Œé”™è¯¯
export class SystemError extends Error {
  constructor(
    message: string,
    public cause?: Error,
    public code?: string
  ) {
    super(message);
    this.name = 'SystemError';
  }
}

// ç½‘ç»œç›¸å…³é”™è¯¯
export class NetworkError extends SystemError {
  constructor(message: string, cause?: Error) {
    super(`ç½‘ç»œé”™è¯¯: ${message}`, cause, 'NETWORK_ERROR');
  }
}
```

### ç»Ÿä¸€é”™è¯¯å¤„ç†
```typescript
export function handleError(error: Error): never {
  if (error instanceof UserError) {
    console.error(chalk.red('âŒ ' + error.message));

    if (error.suggestions.length > 0) {
      console.log(chalk.yellow('\nğŸ’¡ å»ºè®®:'));
      error.suggestions.forEach(suggestion => {
        console.log(chalk.yellow(`   â€¢ ${suggestion}`));
      });
    }
  } else if (error instanceof SystemError) {
    console.error(chalk.red('âŒ ç³»ç»Ÿé”™è¯¯: ' + error.message));

    if (error.cause) {
      console.error(chalk.gray(`   åŸå› : ${error.cause.message}`));
    }

    console.log(chalk.gray('\nå¦‚æœé—®é¢˜æŒç»­å­˜åœ¨ï¼Œè¯·æäº¤ issue åé¦ˆ:'));
    console.log(chalk.blue('https://github.com/Bourne115/busy-cursor-rules/issues'));
  } else {
    console.error(chalk.red('âŒ æœªçŸ¥é”™è¯¯: ' + error.message));
    console.error(chalk.gray('è¯·æ£€æŸ¥è¾“å…¥å‚æ•°æˆ–è”ç³»å¼€å‘è€…'));
  }

  process.exit(1);
}
```

## é…ç½®ç®¡ç†

### é…ç½®æ–‡ä»¶å¤„ç†
é…ç½®ç®¡ç†åœ¨ [src/core/config.ts](mdc:src/core/config.ts)ï¼š

```typescript
// å…¨å±€é…ç½®æ¥å£
interface GlobalConfig {
  preferredTemplates: string[];
  autoUpdate: boolean;
  language: 'en' | 'zh';
  registryUrl?: string;
  cacheDir: string;
}

// é¡¹ç›®é…ç½®æ¥å£
interface ProjectConfig {
  rules: {
    basic: string[];
    modules: string[];
    workflow: string[];
  };
  customRules?: string[];
  excludePatterns?: string[];
}

// é…ç½®æ–‡ä»¶è·¯å¾„
const CONFIG_PATHS = {
  global: path.join(os.homedir(), '.cursor-rules', 'config.json'),
  project: path.join(process.cwd(), '.cursor', 'config.json'),
} as const;
```

### é…ç½®æ“ä½œå‘½ä»¤
```typescript
// é…ç½®è®¾ç½®
export async function setConfig(key: string, value: any): Promise<void> {
  const config = await loadGlobalConfig();

  // æ”¯æŒåµŒå¥—å±æ€§è®¾ç½® (å¦‚: rules.basic)
  const keys = key.split('.');
  let target = config;

  for (let i = 0; i < keys.length - 1; i++) {
    target = target[keys[i]] = target[keys[i]] || {};
  }

  target[keys[keys.length - 1]] = value;

  await saveGlobalConfig(config);
  console.log(chalk.green(`âœ… é…ç½®å·²æ›´æ–°: ${key} = ${value}`));
}

// é…ç½®è·å–
export async function getConfig(key?: string): Promise<void> {
  const config = await loadGlobalConfig();

  if (key) {
    const value = getNestedValue(config, key);
    console.log(`${key}: ${JSON.stringify(value, null, 2)}`);
  } else {
    console.log(JSON.stringify(config, null, 2));
  }
}
```

## æ¨¡æ¿ç³»ç»Ÿé›†æˆ

### æ¨¡æ¿å¤„ç†
æ¨¡æ¿ç›¸å…³é€»è¾‘åœ¨ [src/templates/index.ts](mdc:src/templates/index.ts)ï¼š

```typescript
// æ¨¡æ¿è·å–å’ŒéªŒè¯
export async function getAvailableTemplates(): Promise<RuleTemplate[]> {
  const builtinTemplates = await loadBuiltinTemplates();
  const customTemplates = await loadCustomTemplates();

  return [...builtinTemplates, ...customTemplates];
}

// æ¨¡æ¿åº”ç”¨
export async function applyTemplate(
  templateId: string,
  projectPath: string,
  options: ApplyOptions = {}
): Promise<ApplyResult> {
  const template = await getTemplate(templateId);
  const projectInfo = await detectProject(projectPath);

  // éªŒè¯æ¨¡æ¿å…¼å®¹æ€§
  if (!isTemplateCompatible(template, projectInfo)) {
    throw new UserError(
      `æ¨¡æ¿ ${template.name} ä¸å…¼å®¹å½“å‰é¡¹ç›®ç±»å‹ ${projectInfo.type}`,
      [`å»ºè®®ä½¿ç”¨: ${getCompatibleTemplates(projectInfo).join(', ')}`]
    );
  }

  // ç”Ÿæˆæ–‡ä»¶
  const files = await generateRuleFiles(template, projectInfo, options);

  // å†™å…¥æ–‡ä»¶
  if (!options.dryRun) {
    await writeRuleFiles(files, projectPath, options.force);
  }

  return {
    template,
    files: files.map(f => f.path),
    projectInfo,
  };
}
```

## æ€§èƒ½ä¼˜åŒ–

### å¼‚æ­¥æ“ä½œä¼˜åŒ–
```typescript
// å¹¶å‘å¤„ç†å¤šä¸ªæ¨¡æ¿
export async function processMultipleTemplates(
  templateIds: string[]
): Promise<ProcessResult[]> {
  // ä½¿ç”¨ Promise.allSettled é¿å…ä¸€ä¸ªå¤±è´¥å½±å“å…¶ä»–
  const results = await Promise.allSettled(
    templateIds.map(id => processTemplate(id))
  );

  return results.map((result, index) => ({
    templateId: templateIds[index],
    success: result.status === 'fulfilled',
    data: result.status === 'fulfilled' ? result.value : null,
    error: result.status === 'rejected' ? result.reason : null,
  }));
}

// ç¼“å­˜é‡å¤æ“ä½œ
const templateCache = new Map<string, RuleTemplate>();

export async function getCachedTemplate(id: string): Promise<RuleTemplate> {
  if (templateCache.has(id)) {
    return templateCache.get(id)!;
  }

  const template = await loadTemplate(id);
  templateCache.set(id, template);
  return template;
}
```

### æ–‡ä»¶ç³»ç»Ÿä¼˜åŒ–
```typescript
// æ‰¹é‡æ–‡ä»¶æ“ä½œ
export async function writeMultipleFiles(
  files: Array<{ path: string; content: string }>,
  baseDir: string
): Promise<void> {
  // ç¡®ä¿ç›®å½•å­˜åœ¨
  const dirs = new Set(files.map(f => path.dirname(path.join(baseDir, f.path))));
  await Promise.all([...dirs].map(dir => fs.ensureDir(dir)));

  // å¹¶å‘å†™å…¥æ–‡ä»¶
  await Promise.all(
    files.map(file =>
      fs.writeFile(path.join(baseDir, file.path), file.content, 'utf8')
    )
  );
}
```
